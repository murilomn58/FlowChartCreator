<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>FlowChart Creator ‚Äî Dashboard BI</title>
  <style>
    :root{
      /* Dark dashboard com verde petr√≥leo + neon lim√£o */
      --bg0:#0B0F0E;
      --bg1:#0E2A26;
      --bg2:#1A1F1E;
      --text:#F2F5F3;
      --muted:#C7D0CC;
      --mutedDark:#7A8A85;

      --neonLime:#B6F23A;
      --greenBright:#9FE870;
      --greenMedium:#6FBF4A;
      --greenOlive:#4F6B3A;
      --greenMoss:#3E5A45;
      --danger:#FF6B6B;

      --shadow: 0 16px 48px rgba(0,0,0,.65);
      --radius:18px;
    }

    *{ box-sizing:border-box; margin:0; padding:0; }
    html,body{ height:100%; }

    body{
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background:
        radial-gradient(1100px 700px at 16% 18%, rgba(182,242,58,.08), transparent 62%),
        radial-gradient(900px 650px at 72% 18%, rgba(159,232,112,.06), transparent 60%),
        radial-gradient(1000px 800px at 55% 80%, rgba(62,90,69,.12), transparent 65%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      color:var(--text);
      overflow:hidden;
    }

    .app{ height:100%; display:grid; grid-template-rows:auto 1fr; }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:16px 20px;
      gap:12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(14,42,38,.85), rgba(11,15,14,.40));
      backdrop-filter: blur(12px);
    }

    .brand{ display:flex; align-items:center; gap:12px; }

    .logo{
      width:42px; height:42px;
      border-radius:14px;
      background: linear-gradient(135deg, rgba(182,242,58,.95), rgba(159,232,112,.85));
      box-shadow:
        0 0 0 1px rgba(182,242,58,.28),
        0 18px 40px rgba(182,242,58,.20),
        0 10px 26px rgba(159,232,112,.16);
      position:relative;
      overflow:hidden;
    }
    .logo:before{
      content:"";
      position:absolute;
      inset:-55% -75%;
      background: linear-gradient(90deg, rgba(255,255,255,.55), transparent);
      transform: rotate(22deg);
      opacity:.30;
    }

    .titleWrap{ line-height:1.2; }
    .h1{ font-weight:780; letter-spacing:.2px; font-size:15px; }
    .sub{ font-size:12px; color:var(--muted); margin-top:2px; }

    .toolbar{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }

    .btn{
      border:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(14,42,38,.92), rgba(11,15,14,.92));
      color:var(--text);
      padding:10px 14px;
      border-radius:14px;
      font-size:13px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      transition: all .15s ease;
      box-shadow: 0 8px 18px rgba(0,0,0,.25);
      user-select:none;
    }
    .btn:hover{
      border-color: rgba(182,242,58,.45);
      box-shadow: 0 10px 22px rgba(182,242,58,.14), 0 8px 18px rgba(0,0,0,.25);
    }
    .btn:focus{
      outline: 2px solid rgba(182,242,58,.60);
      outline-offset: 2px;
    }
    .btn:active{ transform: translateY(1px); }

    .btn.primary{
      border-color: rgba(182,242,58,.48);
      background: linear-gradient(180deg, rgba(182,242,58,.18), rgba(14,42,38,.92));
    }
    .btn.danger{
      border-color: rgba(255,107,107,.42);
      background: linear-gradient(180deg, rgba(255,107,107,.16), rgba(14,42,38,.92));
    }

    main{ height:100%; display:grid; grid-template-columns: 330px 1fr; overflow:hidden; }

    aside{
      border-right:1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(14,42,38,.62), rgba(11,15,14,.25));
      backdrop-filter: blur(10px);
      padding:16px;
      overflow:auto;
    }

    .panel{
      background: linear-gradient(180deg, rgba(14,42,38,.86), rgba(11,15,14,.72));
      border:1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      padding:16px;
      box-shadow: var(--shadow);
      margin-bottom:14px;
    }

    .panel h2{ margin:0 0 12px 0; font-size:13px; letter-spacing:.3px; color:var(--text); }
    .small{ font-size:12px; color:var(--muted); line-height:1.4; }

    label{ display:block; font-size:12px; color:var(--muted); margin:12px 0 6px; }

    input[type="text"], input[type="number"], input[type="color"], textarea, select{
      width:100%;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(11,15,14,.55);
      color:var(--text);
      padding:10px 12px;
      outline:none;
      font-family: inherit;
      font-size:13px;
    }
    input:focus, textarea:focus{
      border-color: rgba(182,242,58,.55);
      box-shadow: 0 0 0 3px rgba(182,242,58,.22);
      outline: 2px solid rgba(182,242,58,.38);
      outline-offset: 1px;
    }
    textarea{ resize:vertical; min-height:80px; }
    select{ appearance:none; background-image: linear-gradient(45deg, transparent 50%, rgba(242,245,243,.7) 50%), linear-gradient(135deg, rgba(242,245,243,.7) 50%, transparent 50%); background-position: calc(100% - 18px) calc(1em + 2px), calc(100% - 13px) calc(1em + 2px); background-size: 5px 5px, 5px 5px; background-repeat: no-repeat; padding-right:34px; }
    input[type="color"]{ padding:6px; height:40px; cursor:pointer; }

    .row{ display:flex; gap:10px; }

    .canvasWrap{
      position:relative;
      height:100%;
      overflow:hidden;
      background:
        radial-gradient(circle at 1px 1px, rgba(255,255,255,.04) 1px, transparent 0) 0 0 / 20px 20px,
        radial-gradient(circle at 1px 1px, rgba(182,242,58,.06) 1px, transparent 0) 10px 10px / 20px 20px,
        linear-gradient(90deg, rgba(30,50,45,.18) 1px, transparent 1px) 0 0 / 120px 120px,
        linear-gradient(180deg, rgba(30,50,45,.14) 1px, transparent 1px) 0 0 / 120px 120px;
    }

    #svg{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
      overflow:visible;
    }

    #board{
      position:absolute;
      inset:0;
      overflow:visible;
    }

    .node{
      position:absolute;
      overflow: visible;
      min-width: 220px;
      max-width: 280px;
      padding:12px;
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(14,42,38,.92), rgba(11,15,14,.86));
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: var(--shadow);
      cursor: grab;
      user-select:none;
    }
    .node:active{ cursor:grabbing; }

    .node.selected{
      border-color: rgba(182,242,58,.68);
      box-shadow:
        0 0 0 1px rgba(182,242,58,.28),
        0 18px 54px rgba(182,242,58,.22),
        var(--shadow);
    }

    .nodeHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }

    .chip{
      display:inline-flex;
      align-items:center;
      height:22px;
      padding:0 10px;
      border-radius: 999px;
      font-size:11px;
      white-space:nowrap;
    }

    .nodeTitle{
      font-weight:760;
      font-size:14px;
      letter-spacing:.2px;
      outline:none;
      cursor:text;
      padding:4px 6px;
      border-radius:10px;
      margin-bottom:4px;
    }
    .nodeTitle[contenteditable="true"]:focus{
      box-shadow: inset 0 0 0 2px rgba(182,242,58,.45);
      background: rgba(182,242,58,.10);
    }

    .nodeDesc{
      font-size:12px;
      color:var(--muted);
      line-height:1.4;
      outline:none;
      cursor:text;
      padding:4px 6px;
      border-radius:10px;
      min-height: 18px;
    }
    .nodeDesc[contenteditable="true"]:focus{
      box-shadow: inset 0 0 0 2px rgba(159,232,112,.32);
      background: rgba(159,232,112,.10);
    }

    .ports{
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-top:12px;
    }
    .portGroup{ display:flex; gap:8px; align-items:center; }

    .port{
      width:14px;
      height:14px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 8px 16px rgba(0,0,0,.28);
      cursor: crosshair;
      position:relative;
    }
    .port::after{
      content:"";
      position:absolute;
      inset:-8px;
      border-radius:999px;
    }

    

.quickAdd{
  position:absolute;
  right:-14px;
  top:50%;
  transform: translate(50%,-50%);
  width:30px;
  height:30px;
  border-radius: 999px;
  border: 1px solid rgba(182,242,58,.55);
  background: linear-gradient(180deg, rgba(182,242,58,.18), rgba(11,15,14,.85));
  color: var(--text);
  display:grid;
  place-items:center;
  cursor:pointer;
  box-shadow: 0 14px 28px rgba(0,0,0,.35), 0 0 0 4px rgba(182,242,58,.10);
  transition: transform .12s ease, box-shadow .12s ease, border-color .12s ease;
  font-size:16px;
  line-height:1;
}
.quickAdd:hover{
  transform: translate(50%,-50%) scale(1.06);
  border-color: rgba(159,232,112,.70);
  box-shadow: 0 16px 32px rgba(0,0,0,.40), 0 0 0 5px rgba(159,232,112,.14);
}
.quickAdd:focus{
  outline: 2px solid rgba(182,242,58,.60);
  outline-offset: 3px;
}

.nodeMeta{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  margin-top:10px;
}
.metaChip{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:4px 8px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.05);
  font-size:11px;
  color: var(--muted);
  white-space:nowrap;
  max-width: 100%;
}
.metaChip b{ color: var(--text); font-weight:650; }

.metaChip.status{
  color: var(--text);
  border-color: rgba(182,242,58,.20);
  background: rgba(182,242,58,.10);
}
.metaChip.status.backlog{ background: rgba(122,138,133,.16); border-color: rgba(122,138,133,.35); }
.metaChip.status.doing{ background: rgba(242,245,243,.08); border-color: rgba(242,245,243,.22); }
.metaChip.status.testing{ background: rgba(64,156,255,.16); border-color: rgba(64,156,255,.40); }
.metaChip.status.bugfix{ background: rgba(255,159,67,.16); border-color: rgba(255,159,67,.42); }
.metaChip.status.done{ background: rgba(159,232,112,.16); border-color: rgba(159,232,112,.42); }

.metaChip.overdue{
  border-color: rgba(255,107,107,.42);
  color: #ffd7df;
}
.port:hover{
      border-color: rgba(182,242,58,.68);
      background: rgba(182,242,58,.22);
      box-shadow: 0 0 0 2px rgba(182,242,58,.16), 0 12px 22px rgba(0,0,0,.30);
    }

    .port.in{
      background: rgba(182,242,58,.14);
      border-color: rgba(182,242,58,.32);
    }
    .port.out{
      background: rgba(159,232,112,.14);
      border-color: rgba(159,232,112,.32);
    }

    .nodeActions{ display:flex; gap:8px; }

    .iconBtn{
      width:28px;
      height:28px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(11,15,14,.45);
      display:grid;
      place-items:center;
      color: var(--muted);
      cursor:pointer;
      font-size:14px;
      transition: all .12s ease;
    }
    .iconBtn:hover{
      border-color: rgba(182,242,58,.45);
      color: var(--text);
      box-shadow: 0 0 0 3px rgba(182,242,58,.12);
    }
    .iconBtn:focus{
      outline: 2px solid rgba(182,242,58,.55);
      outline-offset: 2px;
    }
    .iconBtn.delete:hover{
      border-color: rgba(255,107,107,.45);
      color: #ffd7df;
      box-shadow: 0 0 0 3px rgba(255,107,107,.12);
    }

    .toast{
      position:absolute;
      left:50%;
      bottom:20px;
      transform: translateX(-50%);
      background: rgba(14,42,38,.85);
      border:1px solid rgba(182,242,58,.25);
      padding:10px 16px;
      border-radius: 14px;
      color: var(--text);
      font-size:13px;
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: opacity .2s ease, transform .2s ease;
    }
    .toast.show{ opacity:1; transform: translateX(-50%) translateY(-4px); }

    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
      aside{ display:none; }
    }
  
    /* Status (card background + header pill) */
    .node[data-status="backlog"]{ background: rgba(122,138,133,.14); border-color: rgba(122,138,133,.35); }
    .node[data-status="doing"]{ background: rgba(242,245,243,.06); border-color: rgba(242,245,243,.20); }
    .node[data-status="testing"]{ background: rgba(64,156,255,.12); border-color: rgba(64,156,255,.35); }
    .node[data-status="bugfix"]{ background: rgba(255,159,67,.12); border-color: rgba(255,159,67,.38); }
    .node[data-status="done"]{ background: rgba(159,232,112,.12); border-color: rgba(159,232,112,.38); }

    .statusPill{
      display:inline-flex;
      align-items:center;
      height:22px;
      padding:0 10px;
      border-radius: 999px;
      font-size:11px;
      white-space:nowrap;
      border:1px solid rgba(242,245,243,.18);
      color: rgba(242,245,243,.92);
      background: rgba(242,245,243,.08);
    }
    .statusPill.s-backlog{ background: rgba(122,138,133,.18); border-color: rgba(122,138,133,.38); }
    .statusPill.s-doing{ background: rgba(242,245,243,.10); border-color: rgba(242,245,243,.28); }
    .statusPill.s-testing{ background: rgba(64,156,255,.22); border-color: rgba(64,156,255,.45); }
    .statusPill.s-bugfix{ background: rgba(255,159,67,.22); border-color: rgba(255,159,67,.50); }
    .statusPill.s-done{ background: rgba(159,232,112,.20); border-color: rgba(159,232,112,.45); color: rgba(10,18,14,.92); }

    /* Edge selection */
    svg path.edgePath.selected{ stroke-width: 3.5; filter: url(#glow); }
</style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">
        <div class="logo"></div>
        <div class="titleWrap">
          <div class="h1">FlowChart Creator</div>
          <div class="sub">Dashboard BI ‚Äî Fluxos & Processos</div>
        </div>
      </div>

      <div class="toolbar">
        <button class="btn primary" id="addNodeBtn">+ Adicionar</button>
        <button class="btn" id="autoLayoutBtn">Auto Layout</button>
        <button class="btn" id="fitBtn">Fit</button>
        <button class="btn" id="exportBtn">Exportar</button>
        <button class="btn danger" id="clearBtn">Limpar</button>
      </div>
    </header>

    <main>
      <aside>
        <div class="panel">
          <h2>Etapa Selecionada</h2>
          <div class="small" id="noneSelected">Clique em uma etapa para editar.</div>
          <div id="editor" style="display:none;">
            <label for="nodeName">Nome</label>
            <input id="nodeName" type="text" placeholder="Nome da etapa">

            <label for="nodeDesc">Descri√ß√£o</label>
            <textarea id="nodeDesc" placeholder="Descri√ß√£o..."></textarea>

            <label for="nodeLabel">R√≥tulo</label>
            <input id="nodeLabel" type="text" placeholder="Categoria">

            <div class="row" style="margin-top:12px;">
              <div style="flex:1;">
                <label for="nodeInPorts">Entradas</label>
                <input id="nodeInPorts" type="number" min="1" max="6" value="2">
              </div>
              <div style="flex:1;">
                <label for="nodeOutPorts">Sa√≠das</label>
                <input id="nodeOutPorts" type="number" min="1" max="6" value="2">
              </div>
            </div>

            <label for="nodeColor">Cor</label>
            <input id="nodeColor" type="color" value="#B6F23A">

            <label for="nodeOwner">Respons√°vel</label>
            <input id="nodeOwner" type="text" placeholder="Ex: Murilo / Time BI">

            <div class="row" style="margin-top:12px;">
              <div style="flex:1;">
                <label for="nodeDue">Prazo</label>
                <input id="nodeDue" type="date">
              </div>
              <div style="flex:1;">
                <label for="nodeEta">Estimativa (dias)</label>
                <input id="nodeEta" type="number" min="0" step="1" value="0">
              </div>
            </div>

            <label for="nodeStatus">Status</label>
            <select id="nodeStatus">
  <option value="backlog">Backlog</option>
  <option value="doing">Em andamento</option>
  <option value="testing">Teste</option>
  <option value="bugfix">Corre√ß√£o de bugs</option>
  <option value="done">Finalizado</option>
</select>


            <div class="row" style="margin-top:16px;">
              <button class="btn" id="dupBtn" style="flex:1;">Duplicar</button>
              <button class="btn danger" id="delBtn" style="flex:1;">Excluir</button>
            </div>
          </div>
        </div>

        <div class="panel">
          <h2>Dados</h2>
          <div class="small">Salvo automaticamente no navegador.</div>
          <div class="row" style="margin-top:12px;">
            <button class="btn" id="importBtn" style="flex:1;">Importar</button>
            <button class="btn" id="exportBtn2" style="flex:1;">Exportar</button>
          </div>
          <input type="file" id="fileInput" accept=".json" style="display:none;">
        </div>
      </aside>

      <div class="canvasWrap" id="canvasWrap" tabindex="0">
        <svg id="svg"></svg>
        <div id="board"></div>
        <div class="toast" id="toast"></div>
      </div>
    </main>
  </div>

<script>
(() => {
  'use strict';

  const STORAGE_KEY = 'flowchart-creator:v1';

  let state = loadState() || defaultState();
  let selectedNodeId = null;
  let selectedEdgeId = null;
  let draggingNode = null;
  let connecting = null;

  let view = {
    x: state.meta?.view?.x ?? 0,
    y: state.meta?.view?.y ?? 0,
    scale: clamp(state.meta?.view?.scale ?? 1, 0.5, 2)
  };

  const history = [];
  const redoStack = [];
  let lastHistoryTick = 0;

  const board = document.getElementById('board');
  const svg = document.getElementById('svg');
  const canvasWrap = document.getElementById('canvasWrap');
  const toast = document.getElementById('toast');

  const editor = document.getElementById('editor');
  const noneSelected = document.getElementById('noneSelected');
  const nodeName = document.getElementById('nodeName');
  const nodeDesc = document.getElementById('nodeDesc');
  const nodeLabel = document.getElementById('nodeLabel');
  const nodeInPorts = document.getElementById('nodeInPorts');
  const nodeOutPorts = document.getElementById('nodeOutPorts');
  const nodeColor = document.getElementById('nodeColor');
  const nodeOwner = document.getElementById('nodeOwner');
  const nodeDue = document.getElementById('nodeDue');
  const nodeEta = document.getElementById('nodeEta');
  const nodeStatus = document.getElementById('nodeStatus');
  const dupBtn = document.getElementById('dupBtn');
  const delBtn = document.getElementById('delBtn');

  const addNodeBtn = document.getElementById('addNodeBtn');
  const autoLayoutBtn = document.getElementById('autoLayoutBtn');
  const fitBtn = document.getElementById('fitBtn');
  const exportBtn = document.getElementById('exportBtn');
  const exportBtn2 = document.getElementById('exportBtn2');
  const clearBtn = document.getElementById('clearBtn');
  const importBtn = document.getElementById('importBtn');
  const fileInput = document.getElementById('fileInput');

  init();

  function init(){
    pushHistory();
    renderAll();
    attachHandlers();
    scheduleSave();
    setTimeout(() => fitView(), 100);
  }

  function defaultState(){
    const nodes = [
      createNode('Idea√ß√£o', 'Definir problema e objetivos.', 'Discovery', 100, 120),
      createNode('Pesquisa', 'Coletar insights de usu√°rios.', 'Discovery', 400, 120),
      createNode('Wireframes', 'Criar prot√≥tipos visuais.', 'Design', 700, 120),
      createNode('Desenvolvimento', 'Implementar funcionalidades.', 'Dev', 1000, 120),
      createNode('Testes', 'QA e valida√ß√£o.', 'QA', 1300, 120),
      createNode('Lan√ßamento', 'Deploy e monitoramento.', 'Release', 1600, 120),
    ];

    const edges = [];
    for(let i = 0; i < nodes.length - 1; i++){
      edges.push(createEdge(nodes[i].id, nodes[i+1].id, 0, 0));
    }

    return {
      nodes,
      edges,
      meta: { createdAt: new Date().toISOString(), view: {x:0, y:0, scale:1} }
    };
  }

  function createNode(name, desc, label, x, y){
    return {
      id: uid('n'),
      name: name || 'Node',
      desc: desc || '',
      label: label || 'Etapa',
      x, y,
      w: 260,
      h: 130,
      inPorts: 2,
      outPorts: 2,
      color: '#B6F23A',
      owner: '',
      due: '',
      etaDays: 0,
      status: 'backlog'
    };
  }

  function createEdge(from, to, fromPort = 0, toPort = 0){
    return { id: uid('e'), from, to, fromPort, toPort };
  }

  function loadState(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return null;
      const s = JSON.parse(raw);
      if(!s || !Array.isArray(s.nodes) || !Array.isArray(s.edges)) return null;
      return s;
    }catch{ return null; }
  }

  function saveState(){
    try{
      state.meta = state.meta || {};
      state.meta.view = {...view};
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }catch(e){ console.error('Save failed:', e); }
  }

  let saveQueued = false;
  function scheduleSave(){
    if(saveQueued) return;
    saveQueued = true;
    requestAnimationFrame(() => {
      saveQueued = false;
      saveState();
    });
  }

  function snapshot(){
    return {
      state: JSON.parse(JSON.stringify(state)),
      view: {...view}
    };
  }

  function pushHistory(){
    history.push(snapshot());
    if(history.length > 50) history.shift();
    redoStack.length = 0;
    lastHistoryTick = Date.now();
  }

  function markHistory(thresholdMs = 400){
    const now = Date.now();
    if(now - lastHistoryTick >= thresholdMs) pushHistory();
  }

  function undo(){
    if(!history.length){ showToast('Nada para desfazer'); return; }
    redoStack.push(snapshot());
    const prev = history.pop();
    state = prev.state;
    view = prev.view;
    clearSelection();
    renderAll();
    applyView();
    scheduleSave();
    showToast('Desfeito');
  }

  function redo(){
    if(!redoStack.length){ showToast('Nada para refazer'); return; }
    history.push(snapshot());
    const next = redoStack.pop();
    state = next.state;
    view = next.view;
    clearSelection();
    renderAll();
    applyView();
    scheduleSave();
    showToast('Refeito');
  }

  function renderAll(){
    board.innerHTML = '';
    svg.innerHTML = '';
    applyView();
    for(const n of state.nodes) board.appendChild(renderNode(n));
    updateNodeMetricsFromDOM();
    renderEdges();
    updateEdgeSelectionDOM();
    refreshSelectionUI();
  }

  function renderNode(n){
    const el = document.createElement('div');
    el.className = 'node';
    el.dataset.nodeId = n.id;
    el.dataset.status = (n.status || 'backlog');
    el.style.transform = `translate(${n.x}px, ${n.y}px)`;
    el.style.width = (n.w || 260) + 'px';

    const chipStyle = chipStyleFromColor(n.color || '#B6F23A');

    el.innerHTML = `
      <div class="nodeHeader">
        <span class="statusPill ${statusPillClass(n)}" title="Status">${esc(statusLabelFrom(n.status))}</span>
        <div class="nodeActions">
          <button class="iconBtn" data-action="dup">‚éò</button>
          <button class="iconBtn delete" data-action="del">üóë</button>
        </div>
      </div>
      <button class="quickAdd" data-action="quickAdd" title="Conectar etapa (clique e depois selecione o destino) ‚Äî Shift: criar pr√≥xima etapa">Ôºã</button>
      <div class="nodeTitle" contenteditable="true" spellcheck="false">${esc(n.name || 'Node')}</div>
      <div class="nodeDesc" contenteditable="true" spellcheck="false">${esc(n.desc || '')}</div>
      ${renderMeta(n)}
      ${renderPorts(n)}
    `;

    el.addEventListener('pointerdown', (ev) => {
      const target = ev.target;
      const isPort = target?.classList?.contains('port');
      const icon = target?.closest?.('.iconBtn');
      const quick = target?.closest?.('.quickAdd');
      const isEditing = target?.classList?.contains('nodeTitle') || target?.classList?.contains('nodeDesc');

      if(icon){
        const action = icon.getAttribute('data-action');
        if(action === 'del') removeNode(n.id);
        if(action === 'dup') duplicateNode(n.id);
        ev.stopPropagation();
        return;
      }

      if(quick){
        ev.stopPropagation();
        if(ev.shiftKey) return createNextStep(n.id);
        return startConnection(ev, n.id, 0, 'click');
      }

      if(isPort){
        const portType = target.getAttribute('data-port');
        const portIdx = parseInt(target.getAttribute('data-idx') || '0', 10);
        if(portType === 'out') startConnection(ev, n.id, portIdx, 'click');
        return;
      }

      selectNode(n.id);
      if(!isEditing) startNodeDrag(ev, n.id);
    });

    const titleEl = el.querySelector('.nodeTitle');
    const descEl = el.querySelector('.nodeDesc');

    titleEl.addEventListener('input', () => {
      const node = getNode(n.id);
      if(!node) return;
      markHistory(500);
      node.name = sanitize(titleEl.textContent);
      scheduleSave();
      if(selectedNodeId === n.id) nodeName.value = node.name;
    });

    descEl.addEventListener('input', () => {
      const node = getNode(n.id);
      if(!node) return;
      markHistory(500);
      node.desc = sanitize(descEl.textContent);
      scheduleSave();
      if(selectedNodeId === n.id) nodeDesc.value = node.desc;
    });

    el.addEventListener('dragstart', (e) => e.preventDefault());
    return el;
  }



function renderMeta(n){
  const status = (n.status || 'backlog');
  const statusLabel = status === 'doing' ? 'Em andamento'
    : status === 'testing' ? 'Teste'
    : status === 'bugfix' ? 'Corre√ß√£o de bugs'
    : status === 'done' ? 'Finalizado'
    : 'Backlog';

  const due = (n.due || '').trim();
  const dueLabel = due ? fmtDateBR(due) : 'Sem prazo';
  const isOverdue = due && !isDone(status) && (new Date(due + 'T23:59:59').getTime() < Date.now());

  const owner = sanitize(n.owner || '') || 'Sem respons√°vel';
  const eta = Number(n.etaDays || 0) > 0 ? `${Number(n.etaDays)}d` : '';
  const etaHTML = eta ? `<span class="metaChip" data-meta="eta">‚è≥ <b>${esc(eta)}</b></span>` : '';

  return `
    <div class="nodeMeta">
      <span class="metaChip status ${status}" data-meta="status">${esc(statusLabel)}</span>
      <span class="metaChip ${isOverdue ? 'overdue' : ''}" data-meta="due">üìÖ <b>${esc(dueLabel)}</b></span>
      <span class="metaChip" data-meta="owner">üë§ <b>${esc(owner)}</b></span>
      ${etaHTML}
    </div>
  `;
}

  function renderPorts(n){
    const inCount = clampInt(n.inPorts ?? 2, 1, 6);
    const outCount = clampInt(n.outPorts ?? 2, 1, 6);

    const inHTML = Array.from({length: inCount}, (_,i) =>
      `<div class="port in" data-port="in" data-idx="${i}" title="Entrada ${i+1}"></div>`
    ).join('');

    const outHTML = Array.from({length: outCount}, (_,i) =>
      `<div class="port out" data-port="out" data-idx="${i}" title="Sa√≠da ${i+1}"></div>`
    ).join('');

    return `
      <div class="ports">
        <div class="portGroup">${inHTML}</div>
        <div class="portGroup">${outHTML}</div>
      </div>
    `;
  }

  function updateSvgViewBox(){
    // IMPORTANTE:
    // Como pan/zoom √© feito via CSS transform (applyView) tanto no #board quanto no #svg,
    // o viewBox N√ÉO deve ‚Äúcrescer‚Äù com o conte√∫do. Isso encolhe tudo e deixa as setas min√∫sculas.
    // Mantemos o viewBox alinhado ao tamanho do viewport.
    svg.setAttribute('viewBox', `0 0 ${canvasWrap.clientWidth} ${canvasWrap.clientHeight}`);
  }

  function renderEdges(){
    updateSvgViewBox();

    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.innerHTML = `
      <linearGradient id="edgeGrad" x1="0" y1="0" x2="1" y2="0">
        <stop offset="0%" stop-color="rgba(182,242,58,.98)"/>
        <stop offset="50%" stop-color="rgba(111,191,74,.96)"/>
        <stop offset="100%" stop-color="rgba(159,232,112,.98)"/>
      </linearGradient>
      <marker id="arrow" markerUnits="userSpaceOnUse" markerWidth="14" markerHeight="14" refX="11" refY="7" orient="auto">
        <path d="M0,0 L14,7 L0,14 Z" fill="rgba(242,245,243,.92)" />
      </marker>
      <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
        <feGaussianBlur stdDeviation="2.5" result="blur"/>
        <feColorMatrix in="blur" type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 .4 0" result="glow"/>
        <feMerge>
          <feMergeNode in="glow"/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    `;
    svg.appendChild(defs);

    for(const e of state.edges){
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.classList.add('edgePath');
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', 'url(#edgeGrad)');
      path.setAttribute('stroke-width', '2.4');
      path.setAttribute('stroke-linecap', 'round');
      path.setAttribute('marker-end', 'url(#arrow)');
      path.setAttribute('filter', 'url(#glow)');
      path.dataset.edgeId = e.id;
      path.style.pointerEvents = 'stroke';
      path.style.cursor = 'pointer';
      path.addEventListener('pointerdown', (ev) => {
        ev.stopPropagation();
        selectEdge(e.id);
      });
      svg.appendChild(path);
      updateEdgePath(e.id);
    }

    if(connecting){
      const temp = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      temp.setAttribute('id', connecting.tempId);
      temp.setAttribute('fill', 'none');
      temp.setAttribute('stroke', 'rgba(182,242,58,.98)');
      temp.setAttribute('stroke-width', '2.8');
      temp.setAttribute('stroke-linecap', 'round');
      temp.setAttribute('stroke-dasharray', '6 8');
      temp.setAttribute('filter', 'url(#glow)');
      svg.appendChild(temp);
    }
  }

  function updateEdgePath(edgeId){
    const e = state.edges.find(x => x.id === edgeId);
    const path = svg.querySelector(`path[data-edge-id="${CSS.escape(edgeId)}"]`);
    if(!e || !path) return;

    const a = getNode(e.from);
    const b = getNode(e.to);
    if(!a || !b) return;

    const A = getPortPos(a, 'out', e.fromPort ?? 0);
    const B = getPortPos(b, 'in', e.toPort ?? 0);

    // Curvas Bezier suaves e adaptativas
    const distX = Math.abs(B.x - A.x);
    const distY = Math.abs(B.y - A.y);
    const totalDist = Math.sqrt(distX * distX + distY * distY);
    const baseControl = Math.max(60, totalDist * 0.35);
    const verticalBoost = distY > 100 ? Math.min(distY * 0.25, 80) : 0;
    const dx = baseControl + verticalBoost;

    const c1 = {x: A.x + dx, y: A.y};
    const c2 = {x: B.x - dx, y: B.y};

    path.setAttribute('d', `M ${A.x} ${A.y} C ${c1.x} ${c1.y} ${c2.x} ${c2.y} ${B.x} ${B.y}`);

    if(selectedEdgeId === edgeId){
      path.setAttribute('stroke', 'rgba(159,232,112,.98)');
      path.setAttribute('stroke-width', '3.4');
    }else{
      path.setAttribute('stroke', 'url(#edgeGrad)');
      path.setAttribute('stroke-width', '2.4');
    }
  }

  function updateTempPath(clientX, clientY){
    if(!connecting) return;
    const temp = svg.querySelector(`#${CSS.escape(connecting.tempId)}`);
    if(!temp) return;

    const p = clientToCanvas(clientX, clientY);
    const A = {x: connecting.fromX, y: connecting.fromY};
    const B = p;

    const distX = Math.abs(B.x - A.x);
    const distY = Math.abs(B.y - A.y);
    const totalDist = Math.sqrt(distX * distX + distY * distY);
    const baseControl = Math.max(60, totalDist * 0.35);
    const verticalBoost = distY > 100 ? Math.min(distY * 0.25, 80) : 0;
    const dx = baseControl + verticalBoost;

    const c1 = {x: A.x + dx, y: A.y};
    const c2 = {x: B.x - dx, y: B.y};

    temp.setAttribute('d', `M ${A.x} ${A.y} C ${c1.x} ${c1.y} ${c2.x} ${c2.y} ${B.x} ${B.y}`);
  }

function getPortPos(n, portType, idx){
  // Prefer√™ncia: usar o DOM (posi√ß√£o real) ‚Äî corrige linhas fora do lugar quando o node muda de altura/largura
  const type = portType === 'in' ? 'in' : 'out';
  const count = type === 'in'
    ? clampInt(n.inPorts ?? 2, 1, 6)
    : clampInt(n.outPorts ?? 2, 1, 6);
  const i = clampInt(idx ?? 0, 0, Math.max(0, count - 1));

  const nodeEl = board.querySelector(`.node[data-node-id="${CSS.escape(n.id)}"]`);
  if(nodeEl){
    const portEl = nodeEl.querySelector(`.port[data-port="${type}"][data-idx="${i}"]`);
    if(portEl){
      const r = portEl.getBoundingClientRect();
      const cx = r.left + r.width / 2;
      const cy = r.top + r.height / 2;
      return clientToCanvas(cx, cy);
    }

    // fallback baseado no rect do node (ainda mais fiel que usar n.h/n.w)
    const nr = nodeEl.getBoundingClientRect();
    const padding = 12;
    const spacing = 22;
    const portRadius = 7;
    const localY = nr.bottom - padding - portRadius;

    const localX = (type === 'in')
      ? (nr.left + padding + portRadius + i * spacing)
      : (nr.right - padding - portRadius - i * spacing);

    return clientToCanvas(localX, localY);
  }

  // fallback matem√°tico (quando ainda n√£o existe DOM ‚Äî ex.: 1¬∫ render)
  const x = n.x, y = n.y, w = n.w || 260, h = n.h || 130;
  const portY = y + h - 19;
  const spacing = 22;
  if(type === 'in') return {x: x + 19 + i * spacing, y: portY};
  return {x: x + w - 19 - i * spacing, y: portY};
}

  function applyView(){
    const t = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
    board.style.transformOrigin = '0 0';
    svg.style.transformOrigin = '0 0';
    board.style.transform = t;
    svg.style.transform = t;
  }

  function rerenderEdgesOnly(){
    for(const e of state.edges) updateEdgePath(e.id);
  }

  function refreshSelectionUI(){
  // Highlight selected node
  for(const el of board.querySelectorAll('.node')){
    el.classList.toggle('selected', el.dataset.nodeId === selectedNodeId);
  }

  // Highlight selected edge
  rerenderEdgesOnly();

  // Sidebar editor
  if(selectedNodeId){
    const n = getNode(selectedNodeId);
    if(n){
      noneSelected.style.display = 'none';
      editor.style.display = 'block';
      nodeName.value = n.name || '';
      nodeDesc.value = n.desc || '';
      nodeLabel.value = n.label || '';
      nodeInPorts.value = String(clampInt(n.inPorts ?? 2, 1, 6));
      nodeOutPorts.value = String(clampInt(n.outPorts ?? 2, 1, 6));
      nodeColor.value = n.color || '#B6F23A';
      nodeOwner.value = n.owner || '';
      nodeDue.value = n.due || '';
      nodeEta.value = String(n.etaDays ?? 0);
      nodeStatus.value = n.status || 'backlog';
    }
  }else{
    noneSelected.style.display = 'block';
    editor.style.display = 'none';
  }
}

  function attachHandlers(){
    // Captura cliques para o modo "clique-para-conectar" (roda antes dos handlers dos nodes)
    canvasWrap.addEventListener('pointerdown', (ev) => {
      if(connecting && connecting.mode === 'click'){
        ev.preventDefault();
        ev.stopPropagation();
        handleConnectClick(ev);
      }
    }, true);

    canvasWrap.addEventListener('pointerdown', (ev) => {
      if(ev.target === canvasWrap || ev.target === board || ev.target === svg) clearSelection();
    });

    window.addEventListener('resize', () => {
      updateSvgViewBox();
      rerenderEdgesOnly();
    });

    window.addEventListener('keydown', (ev) => {
      if(ev.key === 'Escape' && connecting){ cancelConnection(null); return; }
      if(ev.key === 'Delete' || ev.key === 'Backspace'){
        const tag = (document.activeElement?.tagName || '').toLowerCase();
        const isField = tag === 'input' || tag === 'textarea' || document.activeElement?.isContentEditable;
        if(isField) return;
        if(selectedEdgeId) return removeEdge(selectedEdgeId);
        if(selectedNodeId) return removeNode(selectedNodeId);
      }

      if((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'z'){
        ev.preventDefault();
        const tag = (document.activeElement?.tagName || '').toLowerCase();
        const isField = tag === 'input' || tag === 'textarea' || document.activeElement?.isContentEditable;
        if(isField) return;
        if(ev.shiftKey) redo();
        else undo();
      }

      if((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === '0'){
        ev.preventDefault();
        fitView();
      }
    });

    let inputThrottle = null;
    const throttledInput = (fn, delay = 500) => {
      return () => {
        clearTimeout(inputThrottle);
        inputThrottle = setTimeout(() => { markHistory(100); fn(); }, delay);
        fn();
      };
    };

    nodeName.addEventListener('input', throttledInput(() => {
      const n = getNode(selectedNodeId);
      if(!n) return;
      n.name = nodeName.value;
      syncNodeDOM(n.id);
      scheduleSave();
    }));

    nodeDesc.addEventListener('input', throttledInput(() => {
      const n = getNode(selectedNodeId);
      if(!n) return;
      n.desc = nodeDesc.value;
      syncNodeDOM(n.id);
      scheduleSave();
    }));

    nodeLabel.addEventListener('input', throttledInput(() => {
      const n = getNode(selectedNodeId);
      if(!n) return;
      n.label = nodeLabel.value;
      syncNodeDOM(n.id);
      scheduleSave();
    }));

    nodeInPorts.addEventListener('input', () => {
      const n = getNode(selectedNodeId);
      if(!n) return;
      markHistory();
      n.inPorts = clampInt(parseInt(nodeInPorts.value || '2', 10), 1, 6);
      renderAll();
      selectNode(n.id);
      scheduleSave();
    });

    nodeOutPorts.addEventListener('input', () => {
      const n = getNode(selectedNodeId);
      if(!n) return;
      markHistory();
      n.outPorts = clampInt(parseInt(nodeOutPorts.value || '2', 10), 1, 6);
      renderAll();
      selectNode(n.id);
      scheduleSave();
    });

    nodeColor.addEventListener('input', throttledInput(() => {
      const n = getNode(selectedNodeId);
      if(!n) return;
      n.color = nodeColor.value;
      syncNodeDOM(n.id);
      scheduleSave();
    }, 200));


nodeOwner.addEventListener('input', throttledInput(() => {
  const n = getNode(selectedNodeId);
  if(!n) return;
  n.owner = nodeOwner.value;
  syncNodeDOM(n.id);
  scheduleSave();
}));

nodeDue.addEventListener('change', () => {
  const n = getNode(selectedNodeId);
  if(!n) return;
  markHistory(150);
  n.due = nodeDue.value || '';
  syncNodeDOM(n.id);
  scheduleSave();
});

nodeEta.addEventListener('input', throttledInput(() => {
  const n = getNode(selectedNodeId);
  if(!n) return;
  n.etaDays = clampInt(parseInt(nodeEta.value || '0', 10), 0, 3650);
  syncNodeDOM(n.id);
  scheduleSave();
}, 200));

nodeStatus.addEventListener('change', () => {
  const n = getNode(selectedNodeId);
  if(!n) return;
  markHistory(150);
  n.status = nodeStatus.value || 'backlog';
  syncNodeDOM(n.id);
  scheduleSave();
});

    dupBtn.addEventListener('click', () => { if(selectedNodeId) duplicateNode(selectedNodeId); });
    delBtn.addEventListener('click', () => { if(selectedNodeId) removeNode(selectedNodeId); });

    addNodeBtn.addEventListener('click', addNode);
    autoLayoutBtn.addEventListener('click', autoLayout);
    fitBtn.addEventListener('click', fitView);
    exportBtn.addEventListener('click', exportJSON);
    exportBtn2.addEventListener('click', exportJSON);
    clearBtn.addEventListener('click', () => {
      if(confirm('Limpar tudo?')){
        state = defaultState();
        view = {x:0,y:0,scale:1};
        clearSelection();
        renderAll();
        scheduleSave();
        showToast('Canvas limpo');
      }
    });
    importBtn.addEventListener('click', () => fileInput.click());

    fileInput.addEventListener('change', async () => {
      const f = fileInput.files && fileInput.files[0];
      if(!f) return;
      try{
        const text = await f.text();
        const s = JSON.parse(text);
        if(!s || !Array.isArray(s.nodes) || !Array.isArray(s.edges)) throw new Error('Invalid');
        state = s;
        view = { x: state.meta?.view?.x ?? 0, y: state.meta?.view?.y ?? 0, scale: clamp(state.meta?.view?.scale ?? 1, 0.5, 2) };
        clearSelection();
        renderAll();
        scheduleSave();
        showToast('Importado');
      } catch {
        showToast('Falha ao importar');
      } finally {
        fileInput.value = '';
      }
    });

    // Pan com bot√£o esquerdo no vazio
    let panning = null;
    canvasWrap.addEventListener('pointerdown', (ev) => {
      if(ev.button !== 0) return;
      const onNode = ev.target.closest && ev.target.closest('.node');
      const onPort = ev.target.closest && ev.target.closest('.port');
      if(onNode || onPort) return;
      panning = { startX: ev.clientX, startY: ev.clientY, x: view.x, y: view.y };
      canvasWrap.setPointerCapture(ev.pointerId);
    });

    window.addEventListener('pointermove', (ev) => {
      if(panning){
        view.x = panning.x + (ev.clientX - panning.startX);
        view.y = panning.y + (ev.clientY - panning.startY);
        applyView();
        scheduleSave();
      }
      if(connecting) updateTempPath(ev.clientX, ev.clientY);
      if(draggingNode) moveNodeDuringDrag(ev);
    });

    window.addEventListener('pointerup', (ev) => {
      panning = null;
      if(connecting && connecting.mode === 'drag') finishConnection(ev);
      if(draggingNode) stopNodeDrag(ev);
    });

    // Zoom com Ctrl+scroll
    canvasWrap.addEventListener('wheel', (ev) => {
      if(!(ev.ctrlKey || ev.metaKey)) return;
      ev.preventDefault();
      const delta = -Math.sign(ev.deltaY) * 0.1;
      const oldScale = view.scale;
      const newScale = clamp(oldScale * (1 + delta), 0.5, 2);
      if(newScale === oldScale) return;

      const rect = canvasWrap.getBoundingClientRect();
      const cx = ev.clientX - rect.left;
      const cy = ev.clientY - rect.top;
      view.x = cx - (cx - view.x) * (newScale / oldScale);
      view.y = cy - (cy - view.y) * (newScale / oldScale);
      view.scale = newScale;
      applyView();
      scheduleSave();
      rerenderEdgesOnly();
    }, {passive:false});
  }

  function startNodeDrag(ev, nodeId){
    const n = getNode(nodeId);
    if(!n) return;
    markHistory();
    selectedEdgeId = null;
    selectedNodeId = nodeId;
    refreshSelectionUI();
    const p = clientToCanvas(ev.clientX, ev.clientY);
    draggingNode = { id: nodeId, dx: p.x - n.x, dy: p.y - n.y, pointerId: ev.pointerId };
    canvasWrap.setPointerCapture(ev.pointerId);
  }

  function moveNodeDuringDrag(ev){
    const n = getNode(draggingNode.id);
    if(!n) return;
    const p = clientToCanvas(ev.clientX, ev.clientY);
    n.x = snap(p.x - draggingNode.dx, 10);
    n.y = snap(p.y - draggingNode.dy, 10);
    const el = board.querySelector(`.node[data-node-id="${CSS.escape(n.id)}"]`);
    if(el) el.style.transform = `translate(${n.x}px, ${n.y}px)`;
    rerenderEdgesOnly();
    scheduleSave();
  }

  function stopNodeDrag(ev){
    draggingNode = null;
    try{ canvasWrap.releasePointerCapture(ev.pointerId); }catch{}
  }

function startConnection(ev, fromNodeId, fromPortIdx, mode = 'click'){
  ev.stopPropagation?.();
  const from = getNode(fromNodeId);
  if(!from) return;

  // Clique-para-conectar: clica na sa√≠da e depois clica no destino (node ou porta de entrada).
  const A = getPortPos(from, 'out', fromPortIdx);

  connecting = {
    mode,
    fromNodeId,
    fromPort: fromPortIdx ?? 0,
    fromX: A.x,
    fromY: A.y,
    tempId: 'temp_edge'
  };

  renderAll();
  updateTempPath(ev.clientX, ev.clientY);

  if(mode === 'click'){
    showToast('Selecione o destino (clique na etapa). Esc cancela. Shift no ‚Äú+‚Äù cria nova etapa.');
  }
}

function cancelConnection(msg = 'Conex√£o cancelada'){
  if(!connecting) return;
  connecting = null;
  renderAll();
  if(msg) showToast(msg);
}

function commitEdge(fromId, toId, fromPort = 0, toPort = 0){
  if(!fromId || !toId || fromId === toId){
    showToast('Conex√£o inv√°lida');
    return;
  }

  if(state.edges.some(e =>
    e.from === fromId &&
    e.to === toId &&
    (e.fromPort ?? 0) === (fromPort ?? 0) &&
    (e.toPort ?? 0) === (toPort ?? 0)
  )){
    showToast('Conex√£o j√° existe');
    return;
  }

  markHistory();
  const newEdge = createEdge(fromId, toId, fromPort ?? 0, toPort ?? 0);
  state.edges.push(newEdge);

  selectedEdgeId = newEdge.id;
  selectedNodeId = null;

  renderAll();
  refreshSelectionUI();
  scheduleSave();
  showToast('Conectado');
}

function handleConnectClick(ev){
  if(!connecting || connecting.mode !== 'click') return;

  const target = ev.target;

  // Permite trocar o ponto de sa√≠da sem cancelar o modo
  const outPort = target?.closest?.('.port[data-port="out"]');
  if(outPort){
    const nodeEl = outPort.closest?.('.node');
    const fromId = nodeEl?.dataset?.nodeId;
    const idx = parseInt(outPort.getAttribute('data-idx') || '0', 10);
    if(fromId) return startConnection(ev, fromId, idx, 'click');
  }

  const quick = target?.closest?.('.quickAdd');
  if(quick){
    const nodeEl = quick.closest?.('.node');
    const fromId = nodeEl?.dataset?.nodeId;
    if(!fromId) return;
    if(ev.shiftKey){
      cancelConnection(null);
      return createNextStep(fromId);
    }
    return startConnection(ev, fromId, 0, 'click');
  }

  const inPort = target?.closest?.('.port[data-port="in"]');
  if(inPort){
    const nodeEl = inPort.closest?.('.node');
    const toId = nodeEl?.dataset?.nodeId;
    const toPort = parseInt(inPort.getAttribute('data-idx') || '0', 10);
    const ended = connecting;
    connecting = null;
    return commitEdge(ended.fromNodeId, toId, ended.fromPort ?? 0, toPort);
  }

  const nodeEl = target?.closest?.('.node');
  if(nodeEl){
    const toId = nodeEl?.dataset?.nodeId;
    const ended = connecting;
    connecting = null;
    return commitEdge(ended.fromNodeId, toId, ended.fromPort ?? 0, 0);
  }

  cancelConnection();
}

// Mantido caso voc√™ queira reativar conex√£o por arrasto no futuro
function finishConnection(ev){
  const ended = connecting;
  connecting = null;
  if(!ended) return;

  const el = document.elementFromPoint(ev.clientX, ev.clientY);
  const port = el && el.closest && el.closest('.port[data-port="in"]');
  const toPortIdx = parseInt(port?.getAttribute('data-idx') || '0', 10);
  const nodeEl = port && port.closest && port.closest('.node');

  renderAll();

  if(!nodeEl){ showToast('Conex√£o cancelada'); return; }
  const toId = nodeEl.dataset.nodeId;
  commitEdge(ended.fromNodeId, toId, ended.fromPort ?? 0, toPortIdx);
}

  function selectNode(nodeId){ selectedNodeId = nodeId; selectedEdgeId = null; refreshSelectionUI(); }
  function updateEdgeSelectionDOM(){
    const paths = svg.querySelectorAll('path.edgePath');
    paths.forEach(p => p.classList.toggle('selected', p.dataset.edgeId === selectedEdgeId));
  }

function selectEdge(edgeId){ selectedEdgeId = edgeId; selectedNodeId = null; updateEdgeSelectionDOM(); refreshSelectionUI(); }
  function clearSelection(){ selectedNodeId = null; selectedEdgeId = null; updateEdgeSelectionDOM(); refreshSelectionUI(); }

  function syncNodeDOM(nodeId){
    const n = getNode(nodeId);
    const el = board.querySelector(`.node[data-node-id="${CSS.escape(nodeId)}"]`);
    if(!n || !el) return;

    const titleEl = el.querySelector('.nodeTitle');
    const descEl = el.querySelector('.nodeDesc');
    const statusEl = el.querySelector('.statusPill');

    if(titleEl && sanitize(titleEl.textContent) !== (n.name || '')) titleEl.textContent = n.name || '';
    if(descEl && sanitize(descEl.textContent) !== (n.desc || '')) descEl.textContent = n.desc || '';
    el.dataset.status = (n.status || 'backlog');
    if(statusEl){
      statusEl.textContent = statusLabelFrom(n.status);
      statusEl.className = 'statusPill ' + statusPillClass(n);
    }

    rerenderEdgesOnly();
  }



function createNextStep(fromNodeId){
  const from = getNode(fromNodeId);
  if(!from) return;

  markHistory();

  const nx = (from.x || 0) + (from.w || 260) + 160;
  const ny = (from.y || 0);

  const n = createNode('Nova Etapa', 'Descri√ß√£o...', 'Etapa', nx, ny);
  state.nodes.push(n);
  state.edges.push(createEdge(fromNodeId, n.id, 0, 0));

  renderAll();
  selectNode(n.id);
  scheduleSave();
  showToast('Pr√≥xima etapa criada');
}

  function addNode(){
    markHistory();
    const nextX = 100 + state.nodes.length * 140;
    const nextY = 120 + (state.nodes.length % 3) * 150;
    const n = createNode('Nova Etapa', 'Descri√ß√£o...', 'Etapa', nextX, nextY);
    state.nodes.push(n);
    renderAll();
    selectNode(n.id);
    scheduleSave();
    showToast('Etapa adicionada');
  }

  function duplicateNode(nodeId){
    const n = getNode(nodeId);
    if(!n) return;
    markHistory();
    const copy = { ...n, id: uid('n'), x: n.x + 30, y: n.y + 30, name: (n.name || 'Node') + ' (c√≥pia)' };
    state.nodes.push(copy);
    renderAll();
    selectNode(copy.id);
    scheduleSave();
    showToast('Duplicado');
  }

  function removeNode(nodeId){
    const idx = state.nodes.findIndex(n => n.id === nodeId);
    if(idx < 0) return;
    markHistory();
    state.nodes.splice(idx, 1);
    state.edges = state.edges.filter(e => e.from !== nodeId && e.to !== nodeId);
    if(selectedNodeId === nodeId) selectedNodeId = null;
    if(selectedEdgeId && !state.edges.some(e => e.id === selectedEdgeId)) selectedEdgeId = null;
    renderAll();
    scheduleSave();
    showToast('Etapa removida');
  }

  function removeEdge(edgeId){
    const idx = state.edges.findIndex(e => e.id === edgeId);
    if(idx < 0) return;
    markHistory();
    state.edges.splice(idx, 1);
    if(selectedEdgeId === edgeId) selectedEdgeId = null;
    renderAll();
    scheduleSave();
    showToast('Conex√£o removida');
  }

  function autoLayout(){
    markHistory();
    const nodes = [...state.nodes];
    const byId = new Map(nodes.map(n => [n.id, n]));
    const indeg = new Map(nodes.map(n => [n.id, 0]));
    const adj = new Map(nodes.map(n => [n.id, []]));

    for(const e of state.edges){
      if(!byId.has(e.from) || !byId.has(e.to)) continue;
      indeg.set(e.to, (indeg.get(e.to) || 0) + 1);
      adj.get(e.from).push(e.to);
    }

    const q = [];
    for(const [id,d] of indeg){ if(d === 0) q.push(id); }

    const order = [];
    while(q.length){
      const id = q.shift();
      order.push(id);
      for(const v of adj.get(id) || []){
        indeg.set(v, (indeg.get(v) || 0) - 1);
        if(indeg.get(v) === 0) q.push(v);
      }
    }

    const finalOrder = (order.length === nodes.length) ? order : nodes.map(n => n.id);
    const level = new Map(finalOrder.map(id => [id, 0]));

    for(let iter=0; iter<10; iter++){
      for(const e of state.edges){
        const a = level.get(e.from) ?? 0;
        const b = level.get(e.to) ?? 0;
        if(b <= a) level.set(e.to, a + 1);
      }
    }

    const columns = new Map();
    for(const id of finalOrder){
      const l = level.get(id) ?? 0;
      if(!columns.has(l)) columns.set(l, []);
      columns.get(l).push(id);
    }

    const startX = 100, startY = 120, colGap = 320, rowGap = 170;
    for(const [l, ids] of columns.entries()){
      ids.forEach((id, r) => {
        const n = byId.get(id);
        if(!n) return;
        n.x = startX + l * colGap;
        n.y = startY + r * rowGap;
      });
    }

    renderAll();
    scheduleSave();
    showToast('Layout aplicado');
  }

  function exportJSON(){
    const blob = new Blob([JSON.stringify(state, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'flowchart.json';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(a.href);
    showToast('Exportado');
  }

  function fitView(){
    if(state.nodes.length === 0){
      view = {x:0,y:0,scale:1};
      applyView();
      scheduleSave();
      return;
    }

    const padding = 80;
    const xs = state.nodes.map(n => n.x);
    const ys = state.nodes.map(n => n.y);
    const xe = state.nodes.map(n => n.x + (n.w || 260));
    const ye = state.nodes.map(n => n.y + (n.h || 130));

    const minX = Math.min(...xs);
    const minY = Math.min(...ys);
    const maxX = Math.max(...xe);
    const maxY = Math.max(...ye);

    const w = maxX - minX + padding*2;
    const h = maxY - minY + padding*2;

    const cw = canvasWrap.clientWidth;
    const ch = canvasWrap.clientHeight;

    const s = clamp(Math.min(cw / w, ch / h), 0.5, 1.5);

    view.scale = s;
    view.x = padding * s - minX * s;
    view.y = padding * s - minY * s;

    applyView();
    scheduleSave();
    rerenderEdgesOnly();
    showToast('Enquadrado');
  }

  function getNode(id){ return state.nodes.find(n => n.id === id) || null; }

  function clientToCanvas(clientX, clientY){
    const rect = canvasWrap.getBoundingClientRect();
    const x = (clientX - rect.left - view.x) / view.scale;
    const y = (clientY - rect.top - view.y) / view.scale;
    return {x, y};
  }

  function updateNodeMetricsFromDOM(){
  // Atualiza w/h reais (baseado no DOM), para fitView/layout e viewBox ficarem corretos
  for(const n of state.nodes){
    const el = board.querySelector(`.node[data-node-id="${CSS.escape(n.id)}"]`);
    if(!el) continue;
    const r = el.getBoundingClientRect();
    // Rect inclui escala; converte para coordenadas do canvas
    n.w = Math.round(r.width / view.scale);
    n.h = Math.round(r.height / view.scale);
  }
}

function fmtDateBR(yyyyMmDd){
  const s = String(yyyyMmDd || '').trim();
  const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(s);
  if(!m) return s;
  return `${m[3]}/${m[2]}/${m[1]}`;
}

function isDone(status){
  return String(status || '').toLowerCase() === 'done';
}

function chipStyleFromColor(hex){
    const h = String(hex || '').trim().toLowerCase();
    const ok = /^#[0-9a-f]{6}$/.test(h) ? h : '#B6F23A';
    const n = parseInt(ok.slice(1), 16);
    const r = (n >> 16) & 255;
    const g = (n >> 8) & 255;
    const b = n & 255;
    return {
      tx: `rgb(${r},${g},${b})`,
      bd: `rgba(${r},${g},${b},.35)`,
      bg: `rgba(${r},${g},${b},.14)`
    };
  }

  function uid(prefix){ return `${prefix}_${Math.random().toString(36).slice(2)}_${Date.now().toString(36)}`; }
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function clampInt(v, a, b){ return Math.max(a, Math.min(b, Math.round(Number(v) || a))); }
  function snap(v, step){ return Math.round(v / step) * step; }
  
  function statusLabelFrom(status){
    const s = (status || 'backlog');
    return s === 'doing' ? 'Em andamento'
      : s === 'testing' ? 'Teste'
      : s === 'bugfix' ? 'Corre√ß√£o de bugs'
      : s === 'done' ? 'Finalizado'
      : 'Backlog';
  }
  function statusPillClass(n){
    const s = (n?.status || 'backlog');
    return 's-' + s;
  }

function esc(str){ return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;'); }
  function sanitize(str){ return String(str || '').replace(/\s+/g,' ').trim(); }

  let toastTimer = null;
  function showToast(msg){
    clearTimeout(toastTimer);
    toast.textContent = msg;
    toast.classList.add('show');
    toastTimer = setTimeout(() => toast.classList.remove('show'), 1800);
  }
})();
</script>
</body>
</html>
